(* show functions generated by the BNF converter *)

open AbsCalc

(* use string buffers for efficient string concatenations *)
type showable = Buffer.t -> unit

let show (s : showable) : string = 
    let init_size = 16 in (* you may want to adjust this *)
    let b = Buffer.create init_size in
    s b;
    Buffer.contents b
    
let emptyS : showable = fun buf -> ()

let c2s (c:char) : showable = fun buf -> Buffer.add_char buf c
let s2s (s:string) : showable = fun buf -> Buffer.add_string buf s

let ( >> ) (s1 : showable) (s2 : showable) : showable = fun buf -> s1 buf; s2 buf

let showChar (c:char) : showable = fun buf -> 
    Buffer.add_string buf ("'" ^ Char.escaped c ^ "'")

let showString (s:string) : showable = fun buf -> 
    Buffer.add_string buf ("\"" ^ String.escaped s ^ "\"")

let showList (showFun : 'a -> showable) (xs : 'a list) : showable = fun buf -> 
    let rec f ys = match ys with
        [] -> ()
      | [y] -> showFun y buf
      | y::ys -> showFun y buf; Buffer.add_string buf "; "; f ys 
    in
        Buffer.add_char buf '[';
        f xs;
        Buffer.add_char buf ']'


let showInt (i:int) : showable = s2s (string_of_int i)
let showFloat (f:float) : showable = s2s (string_of_float f)


let rec showExp (e:exp) : showable = match e with
       EAdd (exp0, exp) -> s2s "EAdd" >> c2s ' ' >> c2s '(' >> showExp exp0  >> s2s ", " >>  showExp exp >> c2s ')'
  |    ESub (exp0, exp) -> s2s "ESub" >> c2s ' ' >> c2s '(' >> showExp exp0  >> s2s ", " >>  showExp exp >> c2s ')'
  |    EMul (exp0, exp) -> s2s "EMul" >> c2s ' ' >> c2s '(' >> showExp exp0  >> s2s ", " >>  showExp exp >> c2s ')'
  |    EDiv (exp0, exp) -> s2s "EDiv" >> c2s ' ' >> c2s '(' >> showExp exp0  >> s2s ", " >>  showExp exp >> c2s ')'
  |    EInt integer -> s2s "EInt" >> c2s ' ' >> c2s '(' >> showInt integer >> c2s ')'



