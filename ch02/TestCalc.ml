(* automatically generated by the BNF Converter *)

open Lexing

let parse (c : in_channel) : AbsCalc.exp =
    ParCalc.pExp LexCalc.token (Lexing.from_channel c)
;;

let rec eval e =
  let open AbsCalc in
  match e with
  | EInt n -> n
  | EAdd (e1, e2) -> eval e1 + eval e2
  | ESub (e1, e2) -> eval e1 - eval e2
  | EMul (e1, e2) -> eval e1 * eval e2
  | EDiv (e1, e2) -> eval e1 / eval e2

let showTree (t : AbsCalc.exp) : string =
    "[Abstract syntax]\n\n"^
    (fun x -> ShowCalc.show (ShowCalc.showExp x)) t^ "\n\n"^
    "[Linearized tree]\n\n"^ PrintCalc.printTree PrintCalc.prtExp t^
    "[Evaluated result]\n\n"^ string_of_int (eval t)^
    "\n"
;;

let main () =
    let channel =
        if Array.length Sys.argv > 1 then open_in Sys.argv.(1)
        else stdin
    in
    try print_string (showTree (parse channel));
        flush stdout;
        exit 0
    with BNFC_Util.Parse_error (start_pos, end_pos) ->
        Printf.printf "Parse error at %d.%d-%d.%d\n"
            start_pos.pos_lnum (start_pos.pos_cnum - start_pos.pos_bol)
            end_pos.pos_lnum (end_pos.pos_cnum - end_pos.pos_bol);
        exit 1
;;

main ();;
